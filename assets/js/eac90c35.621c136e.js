"use strict";(self.webpackChunkdoc_site=self.webpackChunkdoc_site||[]).push([[2442],{50810:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"administrator-guide/operations/node-decommissioning-and-maintenance/datanodes","title":"Decommissioning and Maintenance Modes for Datanodes","description":"Datanode Decommission","source":"@site/docs/05-administrator-guide/03-operations/03-node-decommissioning-and-maintenance/03-datanodes.md","sourceDirName":"05-administrator-guide/03-operations/03-node-decommissioning-and-maintenance","slug":"/administrator-guide/operations/node-decommissioning-and-maintenance/datanodes","permalink":"/docs/administrator-guide/operations/node-decommissioning-and-maintenance/datanodes","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ozone-site/tree/HDDS-9225-website-v2/docs/05-administrator-guide/03-operations/03-node-decommissioning-and-maintenance/03-datanodes.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"Datanodes"},"sidebar":"defaultSidebar","previous":{"title":"Storage Container Manager","permalink":"/docs/administrator-guide/operations/node-decommissioning-and-maintenance/storage-container-manager"},"next":{"title":"Disk Replacement","permalink":"/docs/administrator-guide/operations/disk-replacement/"}}');var t=i(86070),a=i(62392);const o={sidebar_label:"Datanodes"},r="Decommissioning and Maintenance Modes for Datanodes",d={},c=[{value:"Datanode Decommission",id:"datanode-decommission",level:2},{value:"Tuning and Monitoring Decommissioning",id:"tuning-and-monitoring-decommissioning",level:3},{value:"Configuration Properties",id:"configuration-properties",level:4},{value:"SCM-Side Properties",id:"scm-side-properties",level:5},{value:"Datanode-Side Properties",id:"datanode-side-properties",level:5},{value:"Metrics",id:"metrics",level:4},{value:"SCM-side Metrics (<code>ReplicationManagerMetrics</code>)",id:"scm-side-metrics-replicationmanagermetrics",level:5},{value:"Datanode-side Metrics (<code>MeasuredReplicator</code> metrics)",id:"datanode-side-metrics-measuredreplicator-metrics",level:5},{value:"Datanode Maintenance Mode",id:"datanode-maintenance-mode",level:2},{value:"Command Line Usage",id:"command-line-usage",level:3},{value:"Configuration Properties",id:"configuration-properties-1",level:3},{value:"Metrics",id:"metrics-1",level:3}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"decommissioning-and-maintenance-modes-for-datanodes",children:"Decommissioning and Maintenance Modes for Datanodes"})}),"\n",(0,t.jsx)(n.h2,{id:"datanode-decommission",children:"Datanode Decommission"}),"\n",(0,t.jsx)(n.p,{children:"The Datanode decommission is the process that removes the existing Datanode from the Ozone cluster while ensuring that the new data should not be written to the decommissioned Datanode. When you initiate the process of decommissioning a Datanode, Ozone automatically ensures that all the storage containers on that Datanode have an additional copy created on another Datanode before the decommission completes. So, Datanode will keep running after it has been decommissioned and may be used for reads, but not for writes until it is stopped manually."}),"\n",(0,t.jsxs)(n.p,{children:["When we initiate the process of decommissioning, first we check the current state of the node, ideally it should be ",(0,t.jsx)(n.code,{children:"IN_SERVICE"}),", then we change it's state to ",(0,t.jsx)(n.code,{children:"DECOMMISSIONING"})," and start the process of decommissioning, it goes through a workflow where the following happens:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"First an event is fired to close any pipelines on the node, which will also close any containers."}),"\n",(0,t.jsx)(n.li,{children:"Next the containers on the node are obtained and checked to see if new replicas are needed. If so, the new replicas are scheduled."}),"\n",(0,t.jsx)(n.li,{children:"After scheduling replication, the node remains pending until replication has completed."}),"\n",(0,t.jsxs)(n.li,{children:["At this stage the node will complete the decommission process and the state of the node will be changed to ",(0,t.jsx)(n.code,{children:"DECOMMISSIONED"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To check the current state of the Datanodes we can execute the following command,"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"ozone admin datanode list\n"})}),"\n",(0,t.jsx)(n.p,{children:"To decommission a Datanode you can execute the following command in CLI,"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"ozone admin datanode decommission [-hV] [-id=<scmServiceId>]\n       [--scm=<scm>] [<hosts>...]\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can enter multiple hosts to decommission multiple Datanodes together."}),"\n",(0,t.jsx)(n.p,{children:"To view the status of a decommissioning Datanode, you can execute the following command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"ozone admin datanode status decommission [-hV] [-id=<scmServiceId>] [--scm=<scm>] [--id=<uuid>] [--ip=<ipAddress>]\n"})}),"\n",(0,t.jsx)(n.p,{children:"You can pass the IP address or UUID of one Datanode to view only the details related to that Datanode."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," To recommission a Datanode you may execute the below command in CLI,"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"ozone admin datanode recommission [-hV] [-id=<scmServiceId>]\n       [--scm=<scm>] [<hosts>...]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"tuning-and-monitoring-decommissioning",children:"Tuning and Monitoring Decommissioning"}),"\n",(0,t.jsx)(n.p,{children:"The process of decommissioning a Datanode involves replicating all its containers to other Datanodes in the cluster. The speed of this process can be tuned, and its progress can be monitored using several configuration properties and metrics."}),"\n",(0,t.jsx)(n.h4,{id:"configuration-properties",children:"Configuration Properties"}),"\n",(0,t.jsxs)(n.p,{children:["Administrators can adjust the following properties in ",(0,t.jsx)(n.code,{children:"ozone-site.xml"})," to control the container replication speed during decommissioning. They are grouped by the component where they are primarily configured."]}),"\n",(0,t.jsx)(n.h5,{id:"scm-side-properties",children:"SCM-Side Properties"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hdds.scm.replication.datanode.replication.limit"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Defines the base limit for concurrent replication commands that the SCM will ",(0,t.jsx)(n.em,{children:"send"})," to a single Datanode."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Default"}),": ",(0,t.jsx)(n.code,{children:"20"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Details"}),": The effective limit for a decommissioning Datanode is this value multiplied by ",(0,t.jsx)(n.code,{children:"hdds.datanode.replication.outofservice.limit.factor"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"datanode-side-properties",children:"Datanode-Side Properties"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"hdds.datanode.replication.outofservice.limit.factor"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": A multiplier to increase replication capacity for ",(0,t.jsx)(n.code,{children:"DECOMMISSIONING"})," or ",(0,t.jsx)(n.code,{children:"MAINTENANCE"})," nodes. This is a key property for tuning decommission speed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Default"}),": ",(0,t.jsx)(n.code,{children:"2.0"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Details"}),": Although this is a Datanode property, it must also be set in the SCM's configuration. The SCM uses it to send more replication commands, and the Datanode uses it to increase its internal resources (threads and queues) to handle the increased load."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"hdds.datanode.replication.queue.limit"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Sets the base size of the queue for incoming replication requests on a Datanode."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Default"}),": ",(0,t.jsx)(n.code,{children:"4096"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Details"}),": For decommissioning nodes, this limit is scaled by ",(0,t.jsx)(n.code,{children:"hdds.datanode.replication.outofservice.limit.factor"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"hdds.datanode.replication.streams.limit"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Purpose"}),": Sets the base number of threads for the replication thread pool on a Datanode."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Default"}),": ",(0,t.jsx)(n.code,{children:"10"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Details"}),": For decommissioning nodes, this limit is also scaled by ",(0,t.jsx)(n.code,{children:"hdds.datanode.replication.outofservice.limit.factor"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By tuning these properties, administrators can balance the decommissioning speed against the impact on the cluster's performance."}),"\n",(0,t.jsx)(n.h4,{id:"metrics",children:"Metrics"}),"\n",(0,t.jsx)(n.p,{children:"The following metrics can be used to monitor the progress of Datanode decommissioning. The names in parentheses are the corresponding Prometheus metric names, which may vary slightly depending on the metrics sink configuration."}),"\n",(0,t.jsxs)(n.h5,{id:"scm-side-metrics-replicationmanagermetrics",children:["SCM-side Metrics (",(0,t.jsx)(n.code,{children:"ReplicationManagerMetrics"}),")"]}),"\n",(0,t.jsx)(n.p,{children:"These metrics are available on the SCM and provide a cluster-wide view of the replication process. During decommissioning, you should see an increase in these metrics. The name in parentheses is the corresponding Prometheus metric name."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"InflightReplication"})," (",(0,t.jsx)(n.code,{children:"replication_manager_metrics_inflight_replication"}),"): The number of container replication requests currently in progress."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"replicationCmdsSentTotal"})," (",(0,t.jsx)(n.code,{children:"replication_manager_metrics_replication_cmds_sent_total"}),"): The total number of replication commands sent to Datanodes."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"replicasCreatedTotal"})," (",(0,t.jsx)(n.code,{children:"replication_manager_metrics_replicas_created_total"}),"): The total number of container replicas successfully created."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"replicateContainerCmdsDeferredTotal"})," (",(0,t.jsx)(n.code,{children:"replication_manager_metrics_replicate_container_cmds_deferred_total"}),"): The number of replication commands deferred because source Datanodes were overloaded. If this value is high, it might indicate that the source Datanodes (including the decommissioning one) are too busy."]}),"\n"]}),"\n",(0,t.jsxs)(n.h5,{id:"datanode-side-metrics-measuredreplicator-metrics",children:["Datanode-side Metrics (",(0,t.jsx)(n.code,{children:"MeasuredReplicator"})," metrics)"]}),"\n",(0,t.jsx)(n.p,{children:"These metrics are available on each Datanode. For a decommissioning node, they show its activity as a source of replicas. For other nodes, they show their activity as targets. The name in parentheses is the corresponding Prometheus metric name."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"success"})," (",(0,t.jsx)(n.code,{children:"measured_replicator_success"}),"): The number of successful replication tasks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"successTime"})," (",(0,t.jsx)(n.code,{children:"measured_replicator_success_time"}),"): The total time spent on successful replication tasks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"transferredBytes"})," (",(0,t.jsx)(n.code,{children:"measured_replicator_transferred_bytes"}),"): The total bytes transferred for successful replications."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"failure"})," (",(0,t.jsx)(n.code,{children:"measured_replicator_failure"}),"): The number of failed replication tasks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"failureTime"})," (",(0,t.jsx)(n.code,{children:"measured_replicator_failure_time"}),"): The total time spent on failed replication tasks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"failureBytes"})," (",(0,t.jsx)(n.code,{children:"measured_replicator_failure_bytes"}),"): The total bytes that failed to be transferred."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"queueTime"})," (",(0,t.jsx)(n.code,{children:"measured_replicator_queue_time"}),"): The total time tasks spend in the replication queue. A high value might indicate the Datanode is overloaded."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By monitoring these metrics, administrators can get a clear picture of the decommissioning progress and identify potential bottlenecks."}),"\n",(0,t.jsx)(n.h2,{id:"datanode-maintenance-mode",children:"Datanode Maintenance Mode"}),"\n",(0,t.jsx)(n.p,{children:"Maintenance mode is a feature in Apache Ozone that allows you to temporarily take a Datanode offline for maintenance operations (e.g., hardware upgrades, software updates) without triggering immediate data replication. Unlike decommissioning, which aims to permanently remove a Datanode and its data from the cluster, maintenance mode is designed for temporary outages."}),"\n",(0,t.jsx)(n.p,{children:"While in maintenance mode, a Datanode does not accept new writes but may still serve reads, assuming containers are healthy and online. Existing data on the Datanode will remain in place, and replication of its data will only be triggered if the Datanode remains in maintenance mode beyond a configurable timeout period. This allows for planned downtime without unnecessary data movement, reducing network overhead and cluster load."}),"\n",(0,t.jsx)(n.p,{children:"The Datanode transitions through the following operational states during maintenance:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IN_SERVICE"}),": The Datanode is fully operational and participating in data writes and reads."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ENTERING_MAINTENANCE"}),": The Datanode is transitioning into maintenance mode. New writes will be avoided."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IN_MAINTENANCE"}),": The Datanode is in maintenance mode. Data will not be written to it. If the Datanode remains in this state beyond the configured maintenance window, its data will start to be replicated to other Datanodes to ensure data durability."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"command-line-usage",children:"Command Line Usage"}),"\n",(0,t.jsxs)(n.p,{children:["To place a Datanode into maintenance mode, use the ",(0,t.jsx)(n.code,{children:"ozone admin datanode maintenance"})," command. You can specify a duration for the maintenance period. If no duration is specified, a default duration will be used (this can be configured)."]}),"\n",(0,t.jsx)(n.p,{children:"To check the current state of the Datanodes, including their operational state, you can execute the following command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"ozone admin datanode list\n"})}),"\n",(0,t.jsx)(n.p,{children:"To start maintenance mode for one or more Datanodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"ozone admin datanode maintenance [-hV] [-id=<scmServiceId>] [--scm=<scm>] [--end=<hours>] [--force] [<hosts>...]\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"<hosts>"}),": A space-separated list of hostnames or IP addresses of the Datanodes to put into maintenance mode."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--end=<hours>"}),": Optional. Automatically end maintenance after the given hours. By default, maintenance must be ended manually."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--force"}),": Optional. Forcefully try to put the Datanode(s) into maintenance mode."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["To take a Datanode out of maintenance mode and return it to ",(0,t.jsx)(n.code,{children:"IN_SERVICE"})," state, you can use the ",(0,t.jsx)(n.code,{children:"recommission"})," command:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"ozone admin datanode recommission [-hV] [-id=<scmServiceId>] [--scm=<scm>] [<hosts>...]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"configuration-properties-1",children:"Configuration Properties"}),"\n",(0,t.jsxs)(n.p,{children:["The following properties, typically set in ",(0,t.jsx)(n.code,{children:"ozone-site.xml"}),", are relevant to maintenance mode:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hdds.scm.replication.maintenance.replica.minimum"}),": The minimum number of container replicas which must be available for a node to enter maintenance. Default value is ",(0,t.jsx)(n.code,{children:"2"}),". If putting a node into maintenance reduces the available replicas for any container below this level, the node will remain in the ",(0,t.jsx)(n.code,{children:"ENTERING_MAINTENANCE"})," state until a new replica is created."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hdds.scm.replication.maintenance.remaining.redundancy"}),": The number of redundant containers in a group which must be available for a node to enter maintenance. Default value is ",(0,t.jsx)(n.code,{children:"1"}),". If putting a node into maintenance reduces the redundancy below this value, the node will remain in the ",(0,t.jsx)(n.code,{children:"ENTERING_MAINTENANCE"})," state until a new replica is created. For Ratis containers, the default value of 1 ensures at least two replicas are online, meaning 1 more can be lost without data becoming unavailable. For any EC container it will have at least dataNum + 1 online, allowing the loss of 1 more replica before data becomes unavailable. Currently only EC containers use this setting. Ratis containers use ",(0,t.jsx)(n.code,{children:"hdds.scm.replication.maintenance.replica.minimum"}),". For EC, if nodes are in maintenance, it is likely reconstruction reads will be required if some of the data replicas are offline. This is seamless to the client, but will affect read performance."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"metrics-1",children:"Metrics"}),"\n",(0,t.jsx)(n.p,{children:"The following SCM metrics are relevant to Datanode maintenance mode:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DecommissioningMaintenanceNodesTotal"}),": This metric reports the total number of Datanodes that are currently in either decommissioning or maintenance mode."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RecommissionNodesTotal"}),": This metric reports the total number of Datanodes that are currently being recommissioned (i.e., returning to ",(0,t.jsx)(n.code,{children:"IN_SERVICE"})," state from either decommissioning or maintenance mode)."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},62392:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var s=i(30758);const t={},a=s.createContext(t);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);