"use strict";(self.webpackChunkdoc_site=self.webpackChunkdoc_site||[]).push([[74401],{2526:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"system-internals/security/symmetric-encryption","title":"Symmetric Encryption Within Ozone","description":"In secure mode, Ozone issues tokens to authorize and verify each block and container access. Traditionally, each token is signed by Ozone Manager (OM) or Storage Container Manager (SCM) using RSA private keys and verified by Datanodes using public keys and certificates. However, with RSA private key sizes of 2048 bits, the signing operation is computationally expensive and can contribute more than 80% to the latency of read/write operations in Ozone Manager.","source":"@site/versioned_docs/version-2.1.0/07-system-internals/05-security/02-symmetric-encryption.md","sourceDirName":"07-system-internals/05-security","slug":"/system-internals/security/symmetric-encryption","permalink":"/docs/system-internals/security/symmetric-encryption","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/ozone-site/tree/master/versioned_docs/version-2.1.0/07-system-internals/05-security/02-symmetric-encryption.md","tags":[],"version":"2.1.0","sidebarPosition":2,"frontMatter":{"sidebar_label":"Symmetric Encryption"},"sidebar":"defaultSidebar","previous":{"title":"Kerberos","permalink":"/docs/system-internals/security/kerberos"},"next":{"title":"Tokens","permalink":"/docs/system-internals/security/tokens"}}');var s=r(86070),t=r(62392);const c={sidebar_label:"Symmetric Encryption"},a="Symmetric Encryption Within Ozone",d={},l=[{value:"Performance Advantages Over Asymmetric Encryption",id:"performance-advantages-over-asymmetric-encryption",level:2},{value:"Shared Secret Model",id:"shared-secret-model",level:2},{value:"Architecture Overview",id:"architecture-overview",level:3},{value:"SecretKey Lifecycle",id:"secretkey-lifecycle",level:2},{value:"Key Structure",id:"key-structure",level:3},{value:"Key Generation and Storage",id:"key-generation-and-storage",level:3},{value:"Key Rotation",id:"key-rotation",level:3},{value:"Key Distribution",id:"key-distribution",level:2},{value:"To Ozone Manager",id:"to-ozone-manager",level:3},{value:"To Datanodes",id:"to-datanodes",level:3},{value:"Handling Special Events",id:"handling-special-events",level:2},{value:"OM Restart",id:"om-restart",level:3},{value:"SCM Restart",id:"scm-restart",level:3},{value:"SCM Failover",id:"scm-failover",level:3},{value:"Missing SecretKey on Datanode",id:"missing-secretkey-on-datanode",level:3},{value:"Compliance and Security Standards",id:"compliance-and-security-standards",level:2},{value:"Algorithm Selection",id:"algorithm-selection",level:3},{value:"Key Generation",id:"key-generation",level:3},{value:"Key Storage",id:"key-storage",level:3},{value:"Key Transfer",id:"key-transfer",level:3},{value:"Related Resources",id:"related-resources",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"symmetric-encryption-within-ozone",children:"Symmetric Encryption Within Ozone"})}),"\n",(0,s.jsx)(n.p,{children:"In secure mode, Ozone issues tokens to authorize and verify each block and container access. Traditionally, each token is signed by Ozone Manager (OM) or Storage Container Manager (SCM) using RSA private keys and verified by Datanodes using public keys and certificates. However, with RSA private key sizes of 2048 bits, the signing operation is computationally expensive and can contribute more than 80% to the latency of read/write operations in Ozone Manager."}),"\n",(0,s.jsx)(n.p,{children:"Since Ozone Manager is not horizontally scalable by design, minimizing operational costs is critical for achieving sub-millisecond latencies. Asymmetric key signing cannot meet this requirement. The solution is to use symmetric-key algorithms, such as HMAC with SHA256, to sign tokens\u2014similar to how HDFS operates. This approach reduces signature generation costs from milliseconds to microseconds."}),"\n",(0,s.jsx)(n.h2,{id:"performance-advantages-over-asymmetric-encryption",children:"Performance Advantages Over Asymmetric Encryption"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"Asymmetric (RSA-2048)"}),(0,s.jsx)(n.th,{children:"Symmetric (HMAC-SHA256)"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Signing Speed"}),(0,s.jsx)(n.td,{children:"Milliseconds"}),(0,s.jsx)(n.td,{children:"Microseconds"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CPU Overhead"}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Low"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Latency Impact"}),(0,s.jsx)(n.td,{children:">80% of OM read/write latency"}),(0,s.jsx)(n.td,{children:"Negligible"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Scalability"}),(0,s.jsx)(n.td,{children:"Limited by signing cost"}),(0,s.jsx)(n.td,{children:"Highly scalable"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"shared-secret-model",children:"Shared Secret Model"}),"\n",(0,s.jsx)(n.p,{children:"Symmetric key algorithms require both the signer (OM) and the verifier (Datanodes) to share the same SecretKey. This necessitates managing SecretKey distribution and lifecycle across Ozone components."}),"\n",(0,s.jsx)(n.h3,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Component Responsibilities:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Component"}),(0,s.jsx)(n.th,{children:"Role"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"SCM"})}),(0,s.jsx)(n.td,{children:"Source of truth. Generates, rotates, stores, and distributes SecretKeys."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"OM"})}),(0,s.jsx)(n.td,{children:"Fetches current SecretKey from SCM, caches it, and signs block tokens using HMAC."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Datanodes"})}),(0,s.jsx)(n.td,{children:"Receive SecretKeys via heartbeat/register, verify tokens using cached keys."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"SecretKey Flow:"})}),"\n",(0,s.jsx)(n.mermaid,{value:'flowchart TB\n    SCM["SCM Leader<br/>SecretKey File"]\n    OM["OM<br/>(HMAC)"]\n    Client["Client"]\n    DN["Datanodes<br/>Verify Token"]\n\n    OM --\x3e|Fetch Current Key| SCM\n    SCM --\x3e|Rotate Daily| OM\n    OM --\x3e|Sign Block Token| Client\n    SCM --\x3e|Distribute Keys<br/>via Heartbeat| DN\n    Client --\x3e|Read/Write with Token| DN'}),"\n",(0,s.jsx)(n.h2,{id:"secretkey-lifecycle",children:"SecretKey Lifecycle"}),"\n",(0,s.jsx)(n.h3,{id:"key-structure",children:"Key Structure"}),"\n",(0,s.jsx)(n.p,{children:"Each SecretKey encapsulates:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ID"}),": Unique identifier for the SecretKey"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"creationTime"}),": Timestamp of key creation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"expiryTime"}),": creationTime + X days (configurable expiry duration)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"secretKey"}),": The actual symmetric key material"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-generation-and-storage",children:"Key Generation and Storage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SCM generates SecretKeys and stores them persistently in the SCM file system"}),"\n",(0,s.jsx)(n.li,{children:"Each SCM generates its own SecretKeys independently"}),"\n",(0,s.jsx)(n.li,{children:"SCM maintains both the current active SecretKey and all non-expired keys"}),"\n",(0,s.jsxs)(n.li,{children:["Keys are stored in a KeyStore file in ",(0,s.jsx)(n.code,{children:"<hdds.metadata.dir>/scm/<hdds.key.dir.name>"})]}),"\n",(0,s.jsx)(n.li,{children:"File permissions are restricted to read-only access for the SCM process owner"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-rotation",children:"Key Rotation"}),"\n",(0,s.jsx)(n.p,{children:"SCM proactively generates and distributes the next SecretKey to ensure the current active key is always available on Datanodes before it becomes active:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// When SCM first starts\ncurrentKey = generateSecretKey();\nnextKey = generateSecretKey();\nallKeys.add(currentKey);\nallKeys.add(nextKey);\n\n// Key rotation (periodic)\ncurrentKey = nextKey;\nnextKey = generateSecretKey();\nallKeys.add(nextKey);\nfilterExpiredSecretKeys(allKeys);\n"})}),"\n",(0,s.jsx)(n.p,{children:"During each rotation cycle:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The previously generated ",(0,s.jsx)(n.code,{children:"nextKey"})," becomes the ",(0,s.jsx)(n.code,{children:"currentKey"})]}),"\n",(0,s.jsxs)(n.li,{children:["A new ",(0,s.jsx)(n.code,{children:"nextKey"})," is generated for the upcoming cycle"]}),"\n",(0,s.jsx)(n.li,{children:"Expired SecretKeys are removed from the active set"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-distribution",children:"Key Distribution"}),"\n",(0,s.jsx)(n.h3,{id:"to-ozone-manager",children:"To Ozone Manager"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"OM retrieves the current SecretKey from SCM (leader) via RPC"}),"\n",(0,s.jsx)(n.li,{children:"For performance, OM caches the SecretKey in memory with a configurable TTL"}),"\n",(0,s.jsx)(n.li,{children:"Signed tokens include the SecretKey ID, allowing Datanodes to identify which key to use for verification"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"to-datanodes",children:"To Datanodes"}),"\n",(0,s.jsx)(n.p,{children:"Datanodes receive SecretKeys through two mechanisms:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Registration"}),": When a Datanode joins or rejoins a cluster, it registers with all SCM instances and fetches all current non-expired SecretKeys"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Heartbeat"}),": During heartbeat processing, SCM checks if new SecretKeys need to be distributed and includes them in the heartbeat response"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Datanodes store SecretKeys in memory using a HashMap for fast lookup by ID. They also periodically remove expired keys."}),"\n",(0,s.jsx)(n.h2,{id:"handling-special-events",children:"Handling Special Events"}),"\n",(0,s.jsx)(n.h3,{id:"om-restart",children:"OM Restart"}),"\n",(0,s.jsx)(n.p,{children:"After restarting, OM calls SCM to fetch and cache the current SecretKey."}),"\n",(0,s.jsx)(n.h3,{id:"scm-restart",children:"SCM Restart"}),"\n",(0,s.jsx)(n.p,{children:"After restarting, SCM:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Reads the stored file to load non-expired SecretKeys"}),"\n",(0,s.jsx)(n.li,{children:"Removes any expired keys"}),"\n",(0,s.jsxs)(n.li,{children:["Assigns the ",(0,s.jsx)(n.code,{children:"currentKey"})," based on timestamps of loaded keys"]}),"\n",(0,s.jsxs)(n.li,{children:["Generates a new ",(0,s.jsx)(n.code,{children:"nextKey"})," if needed"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If all stored keys have expired, SCM behaves as if starting fresh."}),"\n",(0,s.jsxs)(n.p,{children:["The following table illustrates SCM key restoration behavior with a 7-day key expiry period. In this example, ",(0,s.jsx)(n.code,{children:"kN"})," represents a key generated on day N. Assume SCM was running until Day 6 and stored keys k1-k7 (where k6 was ",(0,s.jsx)(n.code,{children:"currentKey"})," and k7 was ",(0,s.jsx)(n.code,{children:"nextKey"}),"), then went down. The table shows what happens when SCM restarts on different days:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Stored Keys"}),(0,s.jsx)(n.th,{children:"Restart Day"}),(0,s.jsx)(n.th,{children:"Key Restoration Result"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"k1-k7"}),(0,s.jsx)(n.td,{children:"Day 6"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"currentKey"})," = k6, ",(0,s.jsx)(n.code,{children:"nextKey"})," = k7, ",(0,s.jsx)(n.code,{children:"allKeys"})," = [k1, k2, k3, k4, k5, k6, k7]"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"k1-k7"}),(0,s.jsx)(n.td,{children:"Day 7"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"currentKey"})," = k7, ",(0,s.jsx)(n.code,{children:"nextKey"})," = generateNewKey(), ",(0,s.jsx)(n.code,{children:"allKeys"})," = [k1, k2, k3, k4, k5, k6, k7, nextKey]"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"k1-k7"}),(0,s.jsx)(n.td,{children:"Day 8"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"currentKey"})," = k7, ",(0,s.jsx)(n.code,{children:"nextKey"})," = generateNewKey(), ",(0,s.jsx)(n.code,{children:"allKeys"})," = [k2, k3, k4, k5, k6, k7, nextKey]"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"k1-k7"}),(0,s.jsx)(n.td,{children:"Day 13"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"currentKey"})," = k7, ",(0,s.jsx)(n.code,{children:"nextKey"})," = generateNewKey(), ",(0,s.jsx)(n.code,{children:"allKeys"})," = [k7, nextKey]"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"k1-k7"}),(0,s.jsx)(n.td,{children:"Day 14"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"currentKey"})," = generateNewKey(), ",(0,s.jsx)(n.code,{children:"nextKey"})," = generateNewKey(), ",(0,s.jsx)(n.code,{children:"allKeys"})," = [currentKey, nextKey]"]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Notes:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Day 6: Same day as shutdown, keys restored as-is"}),"\n",(0,s.jsx)(n.li,{children:"Day 7: k7 promoted to current, new nextKey generated"}),"\n",(0,s.jsx)(n.li,{children:"Day 8: k1 expired (generated Day 1 + 7 days = Day 8), removed from allKeys"}),"\n",(0,s.jsx)(n.li,{children:"Day 13: Only k7 remains valid, k1-k6 all expired"}),"\n",(0,s.jsx)(n.li,{children:"Day 14: All stored keys expired (k7: Day 7 + 7 = Day 14), fresh keys generated"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scm-failover",children:"SCM Failover"}),"\n",(0,s.jsx)(n.p,{children:"When SCM leadership transfers to a new instance:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The new SCM's SecretKeys should already be present on Datanodes (since Datanodes register with all SCM instances)"}),"\n",(0,s.jsx)(n.li,{children:"OM can continue using its cached SecretKey until the cache expires"}),"\n",(0,s.jsx)(n.li,{children:"Edge cases where a Datanode lacks a required SecretKey are handled through eventual consistency mechanisms"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"missing-secretkey-on-datanode",children:"Missing SecretKey on Datanode"}),"\n",(0,s.jsx)(n.p,{children:"If a Datanode cannot find a required SecretKey:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"It triggers an immediate heartbeat to update SecretKeys from all SCMs"}),"\n",(0,s.jsxs)(n.li,{children:["Returns a ",(0,s.jsx)(n.code,{children:"SecretKeyNotFound"})," error to the client"]}),"\n",(0,s.jsx)(n.li,{children:"The client retries with other nodes in the pipeline"}),"\n",(0,s.jsx)(n.li,{children:"If all nodes fail, the client requests fresh block information from OM with a flag to refresh the SecretKey cache"}),"\n",(0,s.jsx)(n.li,{children:"A metric is emitted to expose the situation for monitoring"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"compliance-and-security-standards",children:"Compliance and Security Standards"}),"\n",(0,s.jsx)(n.h3,{id:"algorithm-selection",children:"Algorithm Selection"}),"\n",(0,s.jsxs)(n.p,{children:["Following NIST SP 800-133 recommendations for Message Authentication Codes, Ozone uses ",(0,s.jsx)(n.strong,{children:"HMAC"})," as it is:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Highly performant"}),"\n",(0,s.jsx)(n.li,{children:"Supported by Java Security Core"}),"\n",(0,s.jsx)(n.li,{children:"Compliant with security standards"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The default configuration uses ",(0,s.jsx)(n.strong,{children:"HMAC with SHA256"}),", which provides 128-bit security strength per NIST SP 800-57."]}),"\n",(0,s.jsx)(n.h3,{id:"key-generation",children:"Key Generation"}),"\n",(0,s.jsxs)(n.p,{children:["SecretKeys are generated using Java's ",(0,s.jsx)(n.code,{children:"SecureRandom"}),", which complies with FIPS 140-2 requirements for approved Random Number Generators."]}),"\n",(0,s.jsx)(n.h3,{id:"key-storage",children:"Key Storage"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SecretKeys are persisted in a KeyStore file"}),"\n",(0,s.jsx)(n.li,{children:"File permissions are restricted to owner-only read access"}),"\n",(0,s.jsxs)(n.li,{children:["Location: ",(0,s.jsx)(n.code,{children:"<hdds.metadata.dir>/scm/<hdds.key.dir.name>"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-transfer",children:"Key Transfer"}),"\n",(0,s.jsx)(n.p,{children:"SecretKeys are transferred between SCM, OM, and Datanodes via TLS-protected RPC connections, ensuring confidentiality during transit."}),"\n",(0,s.jsx)(n.h2,{id:"related-resources",children:"Related Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://issues.apache.org/jira/browse/HDDS-7733",children:"HDDS-7733"})," - Performance analysis of token signing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://csrc.nist.gov/publications/detail/sp/800-133/rev-2/final",children:"NIST SP 800-133"})," - Recommendation for Cryptographic Key Generation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final",children:"NIST SP 800-57"})," - Recommendation for Key Management"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},62392:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>a});var i=r(30758);const s={},t=i.createContext(s);function c(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);